/**
 * OmniZap Sticker Command Module
 *
 * M√≥dulo respons√°vel por processar comandos de cria√ß√£o de stickers
 * a partir de imagens e v√≠deos enviados pelos usu√°rios
 *
 * @version 1.0.0
 * @author OmniZap Team
 * @license MIT
 */

const fs = require('fs').promises;
const path = require('path');
const util = require('util');
const { exec } = require('child_process');
const execProm = util.promisify(exec);
const logger = require('../utils/logger/loggerModule');
const { getFileBuffer } = require('../utils/baileys/mediaHelper');
const { addStickerToPack, getUserId } = require('./stickerPackManager');

const TEMP_DIR = path.join(process.cwd(), 'temp', 'stickers');
const STICKER_PREFS_DIR = path.join(process.cwd(), 'temp', 'prefs');
const MAX_FILE_SIZE = 2 * 1024 * 1024; // 2MB

/**
 * Garante que os diret√≥rios necess√°rios existam
 * @returns {Promise<boolean>} true se os diret√≥rios existem ou foram criados com sucesso
 */
async function ensureDirectories() {
  try {
    await fs.mkdir(TEMP_DIR, { recursive: true });
    await fs.mkdir(STICKER_PREFS_DIR, { recursive: true });
    return true;
  } catch (error) {
    logger.error(`[StickerCommand.ensureDirectories] Erro ao criar diret√≥rios necess√°rios: ${error.message}`, {
      label: 'StickerCommand.ensureDirectories',
      error: error.stack,
    });
    return false;
  }
}

/**
 * Extrai detalhes da m√≠dia da mensagem
 * @param {object} message - O objeto da mensagem
 * @returns {{mediaType: string, mediaKey: object, isQuoted?: boolean}|null} - Detalhes da m√≠dia ou null se n√£o encontrada
 */
function extractMediaDetails(message) {
  logger.debug('[StickerCommand.extractMediaDetails] Extraindo detalhes da m√≠dia');

  const messageContent = message.message;
  const quotedMessage = messageContent?.extendedTextMessage?.contextInfo?.quotedMessage;
  const mediaTypes = ['imageMessage', 'videoMessage', 'stickerMessage', 'documentMessage'];

  const findMedia = (source, isQuoted = false) => {
    for (const type of mediaTypes) {
      if (source?.[type]) {
        return { mediaType: type.replace('Message', ''), mediaKey: source[type], isQuoted };
      }
    }
    return null;
  };

  const media = findMedia(messageContent) || findMedia(quotedMessage, true);

  if (!media) logger.debug('[StickerCommand.extractMediaDetails] Nenhuma m√≠dia encontrada na mensagem ou citada.');

  return media;
}

function checkMediaSize(mediaKey, mediaType, maxFileSize = MAX_FILE_SIZE) {
  const fileLength = mediaKey?.fileLength || 0;

  const formatBytes = (bytes) => (bytes / (1024 * 1024)).toFixed(2) + ' MB';

  logger.debug(`[StickerCommand.checkMediaSize] Verificando tamanho da m√≠dia. Tipo: ${mediaType}, Tamanho: ${formatBytes(fileLength)}`);

  if (fileLength > maxFileSize) {
    logger.warn(`[StickerCommand.checkMediaSize] M√≠dia muito grande. Tipo: ${mediaType}, Tamanho: ${formatBytes(fileLength)}`);
    return false;
  }

  return true;
}

/**
 * Obt√©m informa√ß√µes do pacote de sticker
 * @param {string} text - Texto do comando (pode conter nome do pacote e autor)
 * @param {string} sender - ID do remetente
 * @param {string} pushName - Nome do usu√°rio
 * @param {object} message - Objeto da mensagem completo
 * @returns {Promise<{packName: string, packAuthor: string}>} - Informa√ß√µes do pacote
 */
async function getStickerPackInfo(text, sender, pushName, message) {
  logger.debug(`[StickerCommand] Obtendo informa√ß√µes do pacote. Texto: "${text}"`);

  let userId = sender;

  if (sender.endsWith('@g.us') && message?.key?.participant) {
    userId = message.key.participant;
    logger.debug(`[StickerCommand] Mensagem de grupo detectada. Usando ID do participante: ${userId} em vez do ID do grupo: ${sender}`);
  }

  const formattedSender = userId.split('@')[0] || 'unknown';
  const prefsPath = path.join(STICKER_PREFS_DIR, `${formattedSender}.json`);

  let defaultPackName = `ü§ñ OmniZap`;
  let defaultPackAuthor = `üë§ ${pushName || formattedSender}`;

  let savedPrefs = null;
  try {
    const prefsExists = await fs
      .access(prefsPath)
      .then(() => true)
      .catch(() => false);
    if (prefsExists) {
      const prefsData = await fs.readFile(prefsPath, 'utf-8');
      savedPrefs = JSON.parse(prefsData);
      logger.debug(`[StickerCommand] Prefer√™ncias carregadas para ${formattedSender}`);
    }
  } catch (error) {
    logger.warn(`[StickerCommand] Erro ao carregar prefer√™ncias: ${error.message}`);
  }

  if (savedPrefs) {
    defaultPackName = savedPrefs.packName || defaultPackName;
    defaultPackAuthor = savedPrefs.packAuthor || defaultPackAuthor;
  }

  let packName = defaultPackName;
  let packAuthor = defaultPackAuthor;

  if (text && text.trim()) {
    logger.debug(`[StickerCommand] Processando texto para pacote: "${text}"`, {
      textOriginal: text,
      textTrimmed: text.trim(),
      containsPipe: text.includes('|'),
    });

    const parts = text
      .trim()
      .split('|')
      .map((part) => part.trim());

    logger.debug(`[StickerCommand] Partes extra√≠das do texto:`, {
      partsCount: parts.length,
      parts: parts,
    });

    if (parts.length >= 1 && parts[0]) {
      packName = parts[0];
      logger.debug(`[StickerCommand] Definindo nome do pacote: "${packName}" (texto original: "${text}")`);
    }

    if (parts.length >= 2 && parts[1]) {
      packAuthor = parts[1];
      logger.debug(`[StickerCommand] Definindo autor do pacote: "${packAuthor}"`);
    }

    try {
      await fs.writeFile(prefsPath, JSON.stringify({ packName, packAuthor }, null, 2));
      logger.info(`[StickerCommand] Novas prefer√™ncias salvas para ${formattedSender}`);
    } catch (error) {
      logger.error(`[StickerCommand] Erro ao salvar prefer√™ncias: ${error.message}`);
    }
  } else {
    logger.debug(`[StickerCommand] Usando prefer√™ncias padr√£o: Nome: "${packName}", Autor: "${packAuthor}"`);
  }

  packName = packName
    .replace(/#nome/g, pushName || 'Usu√°rio')
    .replace(/#id/g, formattedSender)
    .replace(/#data/g, new Date().toLocaleDateString('pt-BR'));

  packAuthor = packAuthor
    .replace(/#nome/g, pushName || 'Usu√°rio')
    .replace(/#id/g, formattedSender)
    .replace(/#data/g, new Date().toLocaleDateString('pt-BR'));

  logger.debug(`[StickerCommand] Pacote final: Nome: "${packName}", Autor: "${packAuthor}"`);
  return { packName, packAuthor };
}

/**
 * Salva a m√≠dia baixada como arquivo tempor√°rio
 * @param {Buffer} buffer - Buffer da m√≠dia
 * @param {string} mediaType - Tipo de m√≠dia
 * @returns {Promise<string>} - Caminho do arquivo salvo
 */
async function saveTempMedia(buffer, mediaType) {
  if (!buffer || !Buffer.isBuffer(buffer)) {
    throw new Error('Buffer inv√°lido ou n√£o fornecido');
  }

  let extension = '.bin';
  switch (mediaType) {
    case 'image':
      extension = '.jpg';
      break;
    case 'video':
      extension = '.mp4';
      break;
    case 'sticker':
      extension = '.webp';
      break;
    case 'document':
      extension = '.bin';
      break;
  }

  const tempPath = path.join(TEMP_DIR, `media_${Date.now()}${extension}`);
  await fs.writeFile(tempPath, buffer);

  logger.debug(`[StickerCommand] M√≠dia salva em arquivo tempor√°rio: ${tempPath}`);
  return tempPath;
}

/**
 * Converte a m√≠dia para o formato webp (sticker)
 * @param {string} inputPath - Caminho do arquivo de entrada
 * @param {string} mediaType - Tipo de m√≠dia
 * @returns {Promise<string>} - Caminho do sticker
 */
async function convertToWebp(inputPath, mediaType) {
  logger.info(`[StickerCommand] Convertendo m√≠dia para webp. Tipo: ${mediaType}`);

  const outputPath = path.join(TEMP_DIR, `sticker_${Date.now()}.webp`);

  try {
    if (mediaType === 'sticker') {
      await fs.copyFile(inputPath, outputPath);
      return outputPath;
    }

    const filtro = mediaType === 'video' ? 'fps=10,scale=512:512' : 'scale=512:512';
    const ffmpegCommand = `ffmpeg -i "${inputPath}" -vcodec libwebp -lossless 1 -loop 0 -preset default -an -vf "${filtro}" "${outputPath}"`;

    logger.debug(`[StickerCommand] Comando ffmpeg para cria√ß√£o de sticker: ${ffmpegCommand}`);
    await execProm(ffmpegCommand);

    try {
      await fs.access(outputPath);

      try {
        const { stdout } = await execProm(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of csv=p=0 "${outputPath}"`);
        const finalDimensions = stdout.trim().split(',').map(Number);
        logger.info(`[StickerCommand] Convers√£o bem-sucedida. Sticker salvo em: ${outputPath} (Dimens√µes finais: ${finalDimensions[0]}x${finalDimensions[1]})`);
      } catch (error) {
        logger.info(`[StickerCommand] Convers√£o bem-sucedida. Sticker salvo em: ${outputPath} (N√£o foi poss√≠vel obter dimens√µes finais)`);
      }

      return outputPath;
    } catch (error) {
      throw new Error(`Falha ao criar o arquivo de sticker: ${error.message}`);
    }
  } catch (error) {
    logger.error(`[StickerCommand] Erro na convers√£o para webp: ${error.message}`, {
      label: 'StickerCommand.convertToWebp',
      error: error.stack,
    });
    throw new Error(`Erro na convers√£o para webp: ${error.message}`);
  }
}

/**
 * Adiciona metadados ao sticker
 * @param {string} stickerPath - Caminho do arquivo de sticker
 * @param {string} packName - Nome do pacote
 * @param {string} packAuthor - Autor do pacote
 * @returns {Promise<string>} - Caminho do sticker com metadados
 */
async function addStickerMetadata(stickerPath, packName, packAuthor) {
  logger.info(`[StickerCommand] Adicionando metadados ao sticker. Nome: "${packName}", Autor: "${packAuthor}"`);

  try {
    const exifData = {
      'sticker-pack-id': `com.omnizap.${Date.now()}`,
      'sticker-pack-name': packName,
      'sticker-pack-publisher': packAuthor,
    };

    const exifPath = path.join(TEMP_DIR, `exif_${Date.now()}.exif`);

    const exifAttr = Buffer.from([0x49, 0x49, 0x2a, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x41, 0x57, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00]);
    const jsonBuffer = Buffer.from(JSON.stringify(exifData), 'utf8');
    const exifBuffer = Buffer.concat([exifAttr, jsonBuffer]);
    exifBuffer.writeUIntLE(jsonBuffer.length, 14, 4);

    await fs.writeFile(exifPath, exifBuffer);

    try {
      await execProm('which webpmux');
    } catch (error) {
      logger.warn('[StickerCommand] webpmux n√£o encontrado, tentando instalar...');
      try {
        await execProm('apt-get update && apt-get install -y webp');
      } catch (installError) {
        logger.error(`[StickerCommand] Falha ao instalar webpmux: ${installError.message}`);
        throw new Error('webpmux n√£o est√° instalado e n√£o foi poss√≠vel instal√°-lo');
      }
    }

    const outputPath = path.join(TEMP_DIR, `final_${Date.now()}.webp`);
    await execProm(`webpmux -set exif "${exifPath}" "${stickerPath}" -o "${outputPath}"`);

    await fs.unlink(exifPath);

    logger.info(`[StickerCommand] Metadados adicionados com sucesso. Sticker final: ${outputPath}`);
    return outputPath;
  } catch (error) {
    logger.error(`[StickerCommand] Erro ao adicionar metadados: ${error.message}`, {
      label: 'StickerCommand.addStickerMetadata',
      error: error.stack,
    });

    return stickerPath;
  }
}

/**
 * Processa uma m√≠dia e cria um sticker
 * @param {object} baileysClient - Cliente do Baileys
 * @param {object} message - Mensagem original
 * @param {string} sender - ID do remetente (pode ser um ID de grupo ou um ID individual)
 * @param {string} from - ID do chat onde enviar a resposta
 * @param {string} text - Texto adicional (para nome do pacote/autor)
 * @param {Object} options - Op√ß√µes adicionais
 * @param {boolean} [options.preserveOriginalAspect=false] - Preservar propor√ß√£o original da imagem:
 *   - Se true e a imagem for < 512px: Mant√©m o tamanho original sem padding
 *   - Se true e a imagem for >= 512px: Redimensiona mantendo propor√ß√£o e adiciona padding
 *   - Se false: For√ßa tamanho exato 512x512 (padr√£o)
 * @param {boolean} [options.removeBackground=false] - Remover fundo branco/transparente do sticker final
 * @returns {Promise<{success: boolean, message: string, stickerPath?: string}>} - Resultado do processamento
 */
async function processSticker(baileysClient, message, sender, from, text, options = {}) {
  logger.info(`[StickerCommand] Iniciando processamento de sticker para ${sender}`, {
    textParams: text ? `"${text}"` : 'sem texto',
    textLength: text ? text.length : 0,
    hasText: !!text,
    text: text,
    textType: typeof text,
    containsPipe: text ? text.includes('|') : false,
    splitResult: text ? text.split('|').map((part) => part.trim()) : [],
    isGroup: sender.endsWith('@g.us'),
    participant: message.key?.participant,
    remoteJid: message.key?.remoteJid,
  });

  let tempMediaPath = null;
  let stickerPath = null;
  let finalStickerPath = null;

  try {
    const dirsOk = await ensureDirectories();
    if (!dirsOk) {
      return {
        success: false,
        message: '‚ùå Erro interno: N√£o foi poss√≠vel criar os diret√≥rios necess√°rios para o processamento do sticker. Por favor, tente novamente mais tarde ou entre em contato com o suporte.',
      };
    }

    const mediaDetails = extractMediaDetails(message);
    if (!mediaDetails) {
      return {
        success: false,
        message: '‚ùå Nenhuma m√≠dia foi encontrada. Para criar um sticker, por favor:\n\n1. Envie uma imagem ou v√≠deo junto com o comando, ou\n2. Responda a uma mensagem que contenha m√≠dia usando o comando.\n\nFormatos suportados: imagem, v√≠deo curto, documento de imagem.',
      };
    }

    const { mediaType, mediaKey, isQuoted } = mediaDetails;

    if (!checkMediaSize(mediaKey, mediaType)) {
      return {
        success: false,
        message: '‚ùå A m√≠dia selecionada excede o limite de tamanho de 2MB. Para reduzir o tamanho, voc√™ pode:\n\n1. Compactar a m√≠dia antes de enviar\n2. Enviar a m√≠dia sem a op√ß√£o de alta defini√ß√£o (HD)\n3. Cortar a m√≠dia ou reduzir sua resolu√ß√£o\n\nIsso ajudar√° a deixar a m√≠dia mais leve e adequada para cria√ß√£o de stickers.',
      };
    }

    logger.info(`[StickerCommand] Baixando m√≠dia do tipo ${mediaType}...`);
    const buffer = await getFileBuffer(mediaKey, mediaType, {
      maxSize: 5 * 1024 * 1024,
      timeoutMs: 60000,
    });

    if (!buffer) {
      return {
        success: false,
        message: '‚ùå N√£o foi poss√≠vel baixar a m√≠dia. Isso pode ocorrer devido a problemas de conex√£o ou porque o arquivo expirou. Por favor, tente novamente com outra m√≠dia ou mais tarde.',
      };
    }

    tempMediaPath = await saveTempMedia(buffer, mediaType);
    stickerPath = await convertToWebp(tempMediaPath, mediaType);

    const { packName, packAuthor } = await getStickerPackInfo(text, sender, message.pushName || 'Usu√°rio', message);

    finalStickerPath = await addStickerMetadata(stickerPath, packName, packAuthor);

    // Adiciona o sticker ao pack do usu√°rio
    const userId = getUserId(sender, message);
    const packResult = await addStickerToPack(userId, finalStickerPath, packName, packAuthor, message);

    let successMessage = `‚úÖ *Sticker criado com sucesso!*\n\n`;
    successMessage += `üì¶ **Pack:** ${packResult.packName}\n`;
    successMessage += `üéØ **Progresso:** ${packResult.stickerCount}/30 stickers\n`;
    successMessage += `üìä **Total seus stickers:** ${packResult.totalStickers}\n`;
    successMessage += `üìö **Total seus packs:** ${packResult.totalPacks}\n\n`;

    if (packResult.isPackComplete) {
      successMessage += `üéâ **Pack completo!** Use \`/s send ${packResult.packIndex + 1}\` para compartilhar!\n\n`;
    } else {
      const remaining = 30 - packResult.stickerCount;
      successMessage += `‚è≥ **Faltam ${remaining} stickers** para completar este pack\n\n`;
    }

    successMessage += `üí° **Dica:** Use \`/s packs\` para ver todos os seus packs`;

    return {
      success: true,
      message: successMessage,
      stickerPath: finalStickerPath,
    };
  } catch (error) {
    logger.error(`[StickerCommand] Erro ao processar sticker: ${error.message}`, {
      label: 'StickerCommand.processSticker',
      error: error.stack,
    });

    return {
      success: false,
      message: `‚ùå Ocorreu um erro durante a cria√ß√£o do sticker: ${error.message}. Por favor, verifique se a m√≠dia est√° em um formato suportado e tente novamente.`,
    };
  } finally {
    try {
      const filesToDelete = [tempMediaPath, stickerPath].filter((file) => file && file !== finalStickerPath);

      for (const file of filesToDelete) {
        if (file) {
          await fs.unlink(file).catch(() => {});
        }
      }
    } catch (error) {
      logger.warn(`[StickerCommand] Erro ao limpar arquivos tempor√°rios: ${error.message}`);
    }
  }
}

module.exports = {
  processSticker,
  extractMediaDetails,
};
