/**
 * OmniZap Message Controller
 *
 * Controlador respons√°vel pelo processamento e tratamento de mensagens
 * recebidas atrav√©s do WhatsApp via tecnologia Baileys
 *
 * @version 1.0.2
 * @author OmniZap Team
 * @license MIT
 */

require('dotenv').config();

// Importar os novos m√≥dulos
const { cacheManager } = require('../cache/cacheManager');
const { eventHandler } = require('../events/eventHandler');

const COMMAND_PREFIX = process.env.COMMAND_PREFIX || '/';

/**
 * Obt√©m informa√ß√µes detalhadas do grupo do cache
 *
 * @param {String} groupJid - JID do grupo
 * @returns {Object|null} Metadados do grupo ou null
 */
const getGroupInfo = async (groupJid) => {
  try {
    if (!groupJid || !groupJid.endsWith('@g.us')) {
      return null;
    }

    return await cacheManager.getGroupMetadata(groupJid);
  } catch (error) {
    console.error('OmniZap: Erro ao obter informa√ß√µes do grupo:', error);
    return null;
  }
};

/**
 * Processador de mensagens WhatsApp do OmniZap
 *
 * Processa todas as mensagens recebidas atrav√©s da conex√£o WhatsApp,
 * aplicando filtros, valida√ß√µes e executando as a√ß√µes correspondentes
 *
 * @param {Object} messageUpdate - Objeto contendo as mensagens recebidas
 * @param {Object} omniZapClient - Cliente WhatsApp ativo para intera√ß√£o
 * @param {String} qrCodePath - Caminho para o QR Code se necess√°rio
 * @returns {Promise<void>}
 */
const OmniZapMessageProcessor = async (messageUpdate, omniZapClient, qrCodePath) => {
  try {
    for (const messageInfo of messageUpdate?.messages || []) {
      const isGroupMessage = messageInfo.key.remoteJid.endsWith('@g.us');
      const groupJid = isGroupMessage ? messageInfo.key.remoteJid : null;
      const senderJid = isGroupMessage
        ? messageInfo.key.participant || messageInfo.key.remoteJid
        : messageInfo.key.remoteJid;

      if (!messageInfo.message) {
        console.log('OmniZap: Mensagem sem conte√∫do ignorada');
        continue;
      }

      if (messageUpdate.type === 'append') {
        console.log('OmniZap: Mensagem hist√≥rica ignorada');
        continue;
      }

      if (messageInfo.key.fromMe) {
        console.log('OmniZap: Mensagem pr√≥pria ignorada');
        continue;
      }

      if (isGroupMessage) {
        console.log(
          `OmniZap: Processando mensagem de GRUPO - Grupo: ${groupJid}, Remetente: ${senderJid}`,
        );
      } else {
        console.log(`OmniZap: Processando mensagem DIRETA de ${senderJid}`);
      }

      await processOmniZapMessage(
        messageInfo,
        omniZapClient,
        qrCodePath,
        isGroupMessage,
        groupJid,
        senderJid,
      );
    }
  } catch (error) {
    handleOmniZapError(error);
  }
};

/**
 * Processa uma mensagem individual do OmniZap
 *
 * @param {Object} messageInfo - Informa√ß√µes da mensagem
 * @param {Object} omniZapClient - Cliente WhatsApp
 * @param {String} qrCodePath - Caminho do QR Code
 * @param {Boolean} isGroupMessage - Se √© mensagem de grupo
 * @param {String} groupJid - JID do grupo (se for mensagem de grupo)
 * @param {String} senderJid - JID do remetente real
 * @returns {Promise<void>}
 */
const processOmniZapMessage = async (
  messageInfo,
  omniZapClient,
  qrCodePath,
  isGroupMessage,
  groupJid,
  senderJid,
) => {
  try {
    console.log(JSON.stringify(messageInfo, null, 2));
    const messageContent = messageInfo.message;
    const messageId = messageInfo.key.id;

    if (isGroupMessage) {
      console.log(
        `OmniZap: Nova mensagem de GRUPO [${messageId}] - Grupo: ${groupJid}, Remetente: ${senderJid}`,
      );
    } else {
      console.log(`OmniZap: Nova mensagem DIRETA [${messageId}] - Remetente: ${senderJid}`);
    }

    const messageText = extractMessageText(messageContent);

    if (!messageText) {
      console.log('OmniZap: Mensagem sem texto ignorada');
      return;
    }

    if (messageText.startsWith(COMMAND_PREFIX)) {
      await processOmniZapCommand(
        messageText,
        messageInfo,
        omniZapClient,
        isGroupMessage,
        groupJid,
        senderJid,
      );
    } else {
      if (isGroupMessage) {
        console.log(
          `OmniZap: Mensagem normal de grupo processada (sem comando) - Grupo: ${groupJid}`,
        );
      } else {
        console.log('OmniZap: Mensagem normal processada (sem comando)');
      }
    }
  } catch (error) {
    console.error(`OmniZap: Erro ao processar mensagem individual:`, error);
  }
};

/**
 * Extrai o texto de diferentes tipos de mensagem
 *
 * @param {Object} messageContent - Conte√∫do da mensagem
 * @returns {String|null} - Texto extra√≠do ou null
 */
const extractMessageText = (messageContent) => {
  if (messageContent.conversation) {
    return messageContent.conversation;
  }

  if (messageContent.extendedTextMessage?.text) {
    return messageContent.extendedTextMessage.text;
  }

  if (messageContent.imageMessage?.caption) {
    return messageContent.imageMessage.caption;
  }

  if (messageContent.videoMessage?.caption) {
    return messageContent.videoMessage.caption;
  }

  return null;
};

/**
 * Processa comandos do OmniZap baseado em switch case
 *
 * @param {String} messageText - Texto da mensagem
 * @param {Object} messageInfo - Informa√ß√µes da mensagem
 * @param {Object} omniZapClient - Cliente WhatsApp
 * @param {Boolean} isGroupMessage - Se √© mensagem de grupo
 * @param {String} groupJid - JID do grupo (se for mensagem de grupo)
 * @param {String} senderJid - JID do remetente real
 * @returns {Promise<void>}
 */
const processOmniZapCommand = async (
  messageText,
  messageInfo,
  omniZapClient,
  isGroupMessage,
  groupJid,
  senderJid,
) => {
  try {
    const commandText = messageText.slice(COMMAND_PREFIX.length).trim();
    const [command, ...args] = commandText.split(' ');
    const targetJid = isGroupMessage ? groupJid : senderJid; // Para onde enviar a resposta

    if (isGroupMessage) {
      console.log(
        `OmniZap: Comando detectado em GRUPO: ${command} com argumentos:`,
        args,
        `- Grupo: ${groupJid}, Remetente: ${senderJid}`,
      );
    } else {
      console.log(
        `OmniZap: Comando detectado: ${command} com argumentos:`,
        args,
        `- Remetente: ${senderJid}`,
      );
    }

    switch (command.toLowerCase()) {
      case 'tese':
        // Comando de teste usando cache
        if (isGroupMessage) {
          const groupInfo = await getGroupInfo(groupJid);
          if (groupInfo) {
            await omniZapClient.sendMessage(targetJid, {
              text:
                `üìã *Teste - Dados do Cache*\n\n` +
                `üè∑Ô∏è *Nome:* ${groupInfo.subject}\n` +
                `üë• *Participantes:* ${groupInfo._participantCount}\n` +
                `üìÖ *Cache:* ${new Date(groupInfo._cacheTimestamp).toLocaleString('pt-BR')}\n` +
                `üîÑ *√öltimo Acesso:* ${new Date(groupInfo._lastAccessed).toLocaleString('pt-BR')}`,
            });
          } else {
            await omniZapClient.sendMessage(targetJid, {
              text: '‚ùå Dados do grupo n√£o encontrados no cache',
            });
          }
        } else {
          await omniZapClient.sendMessage(targetJid, {
            text: '‚ö†Ô∏è Este comando funciona apenas em grupos',
          });
        }
        break;

      case 'grupo':
      case 'group':
        await sendGroupInfoMessage(omniZapClient, targetJid, isGroupMessage, groupJid, senderJid);
        break;

      case 'help':
      case 'ajuda':
        await sendHelpMessage(omniZapClient, targetJid, isGroupMessage, senderJid);
        break;

      case 'status':
        await sendStatusMessage(omniZapClient, targetJid, isGroupMessage, senderJid);
        break;

      case 'cache':
        await sendCacheDetailsMessage(omniZapClient, targetJid, isGroupMessage, senderJid);
        break;

      default:
        await sendUnknownCommandMessage(
          omniZapClient,
          targetJid,
          command,
          isGroupMessage,
          senderJid,
        );
        break;
    }
  } catch (error) {
    console.error('OmniZap: Erro ao processar comando:', error);
    const targetJid = isGroupMessage ? groupJid : senderJid;
    await sendErrorMessage(omniZapClient, targetJid, isGroupMessage, senderJid);
  }
};

/**
 * Envia informa√ß√µes detalhadas do grupo
 */
const sendGroupInfoMessage = async (
  omniZapClient,
  targetJid,
  isGroupMessage,
  groupJid,
  senderJid,
) => {
  try {
    if (!isGroupMessage) {
      await omniZapClient.sendMessage(targetJid, {
        text: '‚ö†Ô∏è *Comando de Grupo*\n\nEste comando funciona apenas em grupos.',
      });
      return;
    }

    const groupInfo = await getGroupInfo(groupJid);

    if (!groupInfo) {
      await omniZapClient.sendMessage(targetJid, {
        text: '‚ùå *Erro*\n\nN√£o foi poss√≠vel obter informa√ß√µes do grupo.',
      });
      return;
    }

    // Formatar data de cria√ß√£o
    const creationDate = new Date(groupInfo.creation * 1000).toLocaleString('pt-BR', {
      timeZone: 'America/Sao_Paulo',
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });

    // Formatar data de altera√ß√£o do assunto
    const subjectDate = new Date(groupInfo.subjectTime * 1000).toLocaleString('pt-BR', {
      timeZone: 'America/Sao_Paulo',
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });

    // Contar administradores
    const admins = groupInfo.participants?.filter((p) => p.admin === 'admin') || [];
    const members = groupInfo.participants?.filter((p) => p.admin !== 'admin') || [];

    // Determinar configura√ß√µes do grupo
    const groupSettings = [];
    if (groupInfo.announce) groupSettings.push('üîê Apenas administradores podem enviar mensagens');
    if (groupInfo.restrict)
      groupSettings.push('üõ°Ô∏è Apenas administradores podem editar configura√ß√µes');
    if (groupInfo.joinApprovalMode) groupSettings.push('‚úã Aprova√ß√£o necess√°ria para entrar');
    if (!groupInfo.memberAddMode) groupSettings.push('üö´ Membros n√£o podem adicionar outros');
    if (groupInfo.isCommunity) groupSettings.push('üèòÔ∏è Comunidade do WhatsApp');

    const groupInfoText = `üë• *Informa√ß√µes do Grupo*

üè∑Ô∏è *Nome:* ${groupInfo.subject}
üÜî *ID:* \`${groupInfo.id}\`
üìÖ *Criado em:* ${creationDate}
üë§ *Criador:* ${groupInfo.owner.replace('@s.whatsapp.net', '')}

üìù *Assunto alterado em:* ${subjectDate}
‚úèÔ∏è *Alterado por:* ${groupInfo.subjectOwner.replace('@s.whatsapp.net', '')}

üë• *PARTICIPANTES (${groupInfo.size || 0})*
‚Ä¢ üëë Administradores: ${admins.length}
‚Ä¢ üë§ Membros: ${members.length}

‚öôÔ∏è *CONFIGURA√á√ïES*
${groupSettings.length > 0 ? groupSettings.join('\n') : 'üìñ Grupo aberto (configura√ß√µes padr√£o)'}

üìä *CACHE*
‚Ä¢ üîÑ Carregado: ${new Date(groupInfo._cacheTimestamp).toLocaleString('pt-BR')}
‚Ä¢ üìà √öltimo acesso: ${new Date(groupInfo._lastAccessed).toLocaleString('pt-BR')}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üë§ *Solicitado por:* ${senderJid.replace('@s.whatsapp.net', '')}
‚ö° *OmniZap Group Info*`;

    // Se houver muitos participantes, enviar lista separada
    if (groupInfo.participants && groupInfo.participants.length <= 20) {
      let participantsList = `\n\nüë• *LISTA DE PARTICIPANTES*\n\n`;

      // Primeiro os admins
      const adminList = admins
        .map((admin) => `üëë ${admin.id.replace('@s.whatsapp.net', '')}`)
        .join('\n');

      // Depois os membros
      const memberList = members
        .map((member) => `üë§ ${member.id.replace('@s.whatsapp.net', '')}`)
        .join('\n');

      if (adminList) participantsList += adminList;
      if (memberList) participantsList += (adminList ? '\n' : '') + memberList;

      // Verifica se a mensagem n√£o ficar√° muito longa
      if ((groupInfoText + participantsList).length <= 4000) {
        await omniZapClient.sendMessage(targetJid, {
          text: groupInfoText + participantsList,
        });
      } else {
        // Envia em duas partes
        await omniZapClient.sendMessage(targetJid, { text: groupInfoText });
        await new Promise((resolve) => setTimeout(resolve, 1000));
        await omniZapClient.sendMessage(targetJid, { text: participantsList });
      }
    } else {
      await omniZapClient.sendMessage(targetJid, { text: groupInfoText });

      if (groupInfo.participants && groupInfo.participants.length > 20) {
        await new Promise((resolve) => setTimeout(resolve, 1000));
        await omniZapClient.sendMessage(targetJid, {
          text:
            `üìã *Lista de Participantes*\n\n` +
            `‚ö†Ô∏è Grupo com muitos participantes (${groupInfo.participants.length})\n` +
            `Use ${COMMAND_PREFIX}participantes para ver a lista completa.`,
        });
      }
    }

    console.log(
      `OmniZap: Informa√ß√µes do grupo enviadas para ${targetJid} (solicitado por ${senderJid})`,
    );
  } catch (error) {
    console.error('OmniZap: Erro ao enviar informa√ß√µes do grupo:', error);
    await omniZapClient.sendMessage(targetJid, {
      text: '‚ùå *Erro interno*\n\nOcorreu um erro ao obter informa√ß√µes do grupo.',
    });
  }
};

/**
 * Envia mensagem de ajuda com todos os comandos dispon√≠veis
 */
const sendHelpMessage = async (
  omniZapClient,
  targetJid,
  isGroupMessage = false,
  senderJid = null,
) => {
  try {
    const contextInfo = isGroupMessage
      ? `\n\nüë• *Contexto:* Mensagem de grupo\nüë§ *Solicitante:* ${senderJid}`
      : `\n\nüë§ *Contexto:* Mensagem direta`;

    const helpText = `ü§ñ *OmniZap - Central de Ajuda*

üìã *COMANDOS DISPON√çVEIS:*

${COMMAND_PREFIX}*help* ou ${COMMAND_PREFIX}*ajuda*
‚Ä¢ Mostra esta mensagem de ajuda

${COMMAND_PREFIX}*status*
‚Ä¢ Exibe status completo do sistema
‚Ä¢ Informa√ß√µes de cache, mem√≥ria e arquitetura

${COMMAND_PREFIX}*cache*
‚Ä¢ Detalhes avan√ßados do sistema de cache
‚Ä¢ Estat√≠sticas de hits/misses por m√≥dulo
‚Ä¢ Informa√ß√µes de TTL (tempo de vida)

${COMMAND_PREFIX}*grupo* ou ${COMMAND_PREFIX}*group*
‚Ä¢ Informa√ß√µes detalhadas do grupo (apenas em grupos)
‚Ä¢ Lista de participantes e configura√ß√µes
‚Ä¢ Dados obtidos do cache inteligente

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üèóÔ∏è *ARQUITETURA MODULAR:*
‚Ä¢ Socket Controller - Gerencia conex√µes
‚Ä¢ Cache Manager - Sistema de cache avan√ßado
‚Ä¢ Event Handler - Processamento de eventos
‚Ä¢ Message Controller - L√≥gica de neg√≥cios

‚ö° *OmniZap v1.0.1*
üîß Sistema Profissional de Automa√ß√£o WhatsApp${contextInfo}`;

    await omniZapClient.sendMessage(targetJid, { text: helpText });

    if (isGroupMessage) {
      console.log(`OmniZap: Ajuda enviada para grupo ${targetJid} (solicitada por ${senderJid})`);
    } else {
      console.log(`OmniZap: Ajuda enviada para ${targetJid}`);
    }
  } catch (error) {
    console.error('OmniZap: Erro ao enviar ajuda:', error);
    await omniZapClient.sendMessage(targetJid, {
      text: '‚ùå *Erro interno*\n\nOcorreu um erro ao exibir a ajuda.',
    });
  }
};

/**
 * Envia mensagem com status detalhado do sistema OmniZap
 */
const sendStatusMessage = async (
  omniZapClient,
  targetJid,
  isGroupMessage = false,
  senderJid = null,
) => {
  try {
    const stats = cacheManager.getStats();

    if (!stats) {
      await omniZapClient.sendMessage(targetJid, {
        text: '‚ùå *Erro ao obter estat√≠sticas*\n\nN√£o foi poss√≠vel recuperar os dados do sistema.',
      });
      return;
    }

    // Obter informa√ß√µes do sistema
    const uptime = process.uptime();
    const memoryUsage = process.memoryUsage();
    const currentDate = new Date().toLocaleString('pt-BR', {
      timeZone: 'America/Sao_Paulo',
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
    });

    // Formata√ß√£o de tempo de atividade
    const formatUptime = (seconds) => {
      const days = Math.floor(seconds / 86400);
      const hours = Math.floor((seconds % 86400) / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const secs = Math.floor(seconds % 60);
      return `${days}d ${hours}h ${minutes}m ${secs}s`;
    };

    // Formata√ß√£o de mem√≥ria
    const formatMemory = (bytes) => {
      const mb = (bytes / 1024 / 1024).toFixed(2);
      return `${mb} MB`;
    };

    // Formata√ß√£o de taxa de acerto
    const formatHitRate = (rate) => {
      const numRate = parseFloat(rate);
      if (numRate >= 80) return `üü¢ ${rate}%`;
      if (numRate >= 60) return `üü° ${rate}%`;
      return `üî¥ ${rate}%`;
    };

    const contextInfo = isGroupMessage
      ? `\n\nüë• *Contexto:* Grupo ${targetJid}\nüë§ *Solicitante:* ${senderJid}`
      : `\n\nüë§ *Contexto:* Mensagem direta`;

    const statusText = `üöÄ *OmniZap - Status do Sistema*

üìä *ESTAT√çSTICAS GERAIS*
‚Ä¢ ‚è∞ Data/Hora: ${currentDate}
‚Ä¢ üîÑ Tempo Ativo: ${formatUptime(uptime)}
‚Ä¢ üóùÔ∏è Total de Chaves: ${stats.totals.allKeys.toLocaleString()}
‚Ä¢ ‚úÖ Total Hits: ${stats.totals.allHits.toLocaleString()}
‚Ä¢ ‚ùå Total Misses: ${stats.totals.allMisses.toLocaleString()}
‚Ä¢ üìà Taxa Geral: ${formatHitRate(
      stats.totals.allHits > 0
        ? ((stats.totals.allHits / (stats.totals.allHits + stats.totals.allMisses)) * 100).toFixed(
            2,
          )
        : '0',
    )}

üí¨ *CACHE DE MENSAGENS*
‚Ä¢ üì® Total Chaves: ${stats.messages.keys.toLocaleString()}
‚Ä¢ ‚úÖ Hits: ${stats.messages.hits.toLocaleString()}
‚Ä¢ ‚ùå Misses: ${stats.messages.misses.toLocaleString()}
‚Ä¢ üìà Taxa Acerto: ${formatHitRate(stats.messages.hitRate)}

üîÑ *CACHE DE EVENTOS*
‚Ä¢ üéØ Total Chaves: ${stats.events.keys.toLocaleString()}
‚Ä¢ ‚úÖ Hits: ${stats.events.hits.toLocaleString()}
‚Ä¢ ‚ùå Misses: ${stats.events.misses.toLocaleString()}
‚Ä¢ üìà Taxa Acerto: ${formatHitRate(stats.events.hitRate)}`;

    const statusText2 = `

üë• *CACHE DE GRUPOS*
‚Ä¢ üè∑Ô∏è Total Chaves: ${stats.groups.keys.toLocaleString()}
‚Ä¢ ‚úÖ Hits: ${stats.groups.hits.toLocaleString()}
‚Ä¢ ‚ùå Misses: ${stats.groups.misses.toLocaleString()}
‚Ä¢ üìà Taxa Acerto: ${formatHitRate(stats.groups.hitRate)}

üë§ *CACHE DE CONTATOS*
‚Ä¢ üìá Total Chaves: ${stats.contacts.keys.toLocaleString()}
‚Ä¢ ‚úÖ Hits: ${stats.contacts.hits.toLocaleString()}
‚Ä¢ ‚ùå Misses: ${stats.contacts.misses.toLocaleString()}
‚Ä¢ üìà Taxa Acerto: ${formatHitRate(stats.contacts.hitRate)}

üí¨ *CACHE DE CHATS*
‚Ä¢ üí≠ Total Chaves: ${stats.chats.keys.toLocaleString()}
‚Ä¢ ‚úÖ Hits: ${stats.chats.hits.toLocaleString()}
‚Ä¢ ‚ùå Misses: ${stats.chats.misses.toLocaleString()}
‚Ä¢ üìà Taxa Acerto: ${formatHitRate(stats.chats.hitRate)}

üñ•Ô∏è *SISTEMA*
‚Ä¢ üíæ Mem√≥ria Usada: ${formatMemory(memoryUsage.heapUsed)}
‚Ä¢ üìä Mem√≥ria Total: ${formatMemory(memoryUsage.heapTotal)}
‚Ä¢ üîÑ RSS: ${formatMemory(memoryUsage.rss)}
‚Ä¢ üìà Mem√≥ria Externa: ${formatMemory(memoryUsage.external)}

üèóÔ∏è *ARQUITETURA MODULAR*
‚Ä¢ üîó Socket Controller: ‚úÖ Ativo
‚Ä¢ üîÑ Cache Manager: ‚úÖ Ativo  
‚Ä¢ üéØ Event Handler: ‚úÖ Ativo
‚Ä¢ üí¨ Message Controller: ‚úÖ Ativo`;

    const finalStatusText =
      statusText +
      statusText2 +
      `

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚ö° *OmniZap v1.0.1*
üîß Sistema de Cache Avan√ßado
üèóÔ∏è Arquitetura Modular${contextInfo}`;

    // Enviar mensagem dividida se for muito longa
    if (finalStatusText.length > 4096) {
      // Dividir em duas partes
      await omniZapClient.sendMessage(targetJid, { text: statusText });
      await new Promise((resolve) => setTimeout(resolve, 1000)); // Delay de 1 segundo
      await omniZapClient.sendMessage(targetJid, {
        text:
          statusText2 +
          `

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚ö° *OmniZap v1.0.1*
üîß Sistema de Cache Avan√ßado
üèóÔ∏è Arquitetura Modular${contextInfo}`,
      });
    } else {
      await omniZapClient.sendMessage(targetJid, { text: finalStatusText });
    }

    if (isGroupMessage) {
      console.log(`OmniZap: Status enviado para grupo ${targetJid} (solicitado por ${senderJid})`);
    } else {
      console.log(`OmniZap: Status enviado para ${targetJid}`);
    }
  } catch (error) {
    console.error('OmniZap: Erro ao enviar status:', error);
    await omniZapClient.sendMessage(targetJid, {
      text: '‚ùå *Erro interno*\n\nOcorreu um erro ao obter o status do sistema.',
    });
  }
};

/**
 * Envia mensagem com detalhes avan√ßados do cache
 */
const sendCacheDetailsMessage = async (
  omniZapClient,
  targetJid,
  isGroupMessage = false,
  senderJid = null,
) => {
  try {
    const stats = cacheManager.getStats();

    if (!stats) {
      await omniZapClient.sendMessage(targetJid, {
        text: '‚ùå *Erro ao obter detalhes do cache*\n\nN√£o foi poss√≠vel recuperar os dados.',
      });
      return;
    }

    // Formata√ß√£o de taxa de acerto
    const formatHitRate = (rate) => {
      const numRate = parseFloat(rate);
      if (numRate >= 80) return `üü¢ ${rate}%`;
      if (numRate >= 60) return `üü° ${rate}%`;
      return `üî¥ ${rate}%`;
    };

    const contextInfo = isGroupMessage
      ? `\n\nüë• *Contexto:* Grupo ${targetJid}\nüë§ *Solicitante:* ${senderJid}`
      : `\n\nüë§ *Contexto:* Mensagem direta`;

    const cacheDetailsText = `üîÑ *Detalhes do Cache OmniZap*

üìä *RESUMO GERAL*
‚Ä¢ üîë Total de Chaves: ${stats.totals.allKeys.toLocaleString()}
‚Ä¢ ‚úÖ Total de Hits: ${stats.totals.allHits.toLocaleString()}
‚Ä¢ ‚ùå Total de Misses: ${stats.totals.allMisses.toLocaleString()}
‚Ä¢ üìà Taxa Geral: ${formatHitRate(
      stats.totals.allHits > 0
        ? ((stats.totals.allHits / (stats.totals.allHits + stats.totals.allMisses)) * 100).toFixed(
            2,
          )
        : '0',
    )}

üí¨ *MENSAGENS (TTL: 1h)*
‚Ä¢ üîë Chaves: ${stats.messages.keys.toLocaleString()}
‚Ä¢ ‚úÖ Hits: ${stats.messages.hits.toLocaleString()}
‚Ä¢ ‚ùå Misses: ${stats.messages.misses.toLocaleString()}
‚Ä¢ üìà Taxa: ${formatHitRate(stats.messages.hitRate)}

üéØ *EVENTOS (TTL: 30min)*
‚Ä¢ üîë Chaves: ${stats.events.keys.toLocaleString()}
‚Ä¢ ‚úÖ Hits: ${stats.events.hits.toLocaleString()}
‚Ä¢ ‚ùå Misses: ${stats.events.misses.toLocaleString()}
‚Ä¢ üìà Taxa: ${formatHitRate(stats.events.hitRate)}

üë• *GRUPOS (TTL: 2h)*
‚Ä¢ üîë Chaves: ${stats.groups.keys.toLocaleString()}
‚Ä¢ ‚úÖ Hits: ${stats.groups.hits.toLocaleString()}
‚Ä¢ ‚ùå Misses: ${stats.groups.misses.toLocaleString()}
‚Ä¢ üìà Taxa: ${formatHitRate(stats.groups.hitRate)}

üë§ *CONTATOS (TTL: 4h)*
‚Ä¢ üîë Chaves: ${stats.contacts.keys.toLocaleString()}
‚Ä¢ ‚úÖ Hits: ${stats.contacts.hits.toLocaleString()}
‚Ä¢ ‚ùå Misses: ${stats.contacts.misses.toLocaleString()}
‚Ä¢ üìà Taxa: ${formatHitRate(stats.contacts.hitRate)}

üí¨ *CHATS (TTL: 1h)*
‚Ä¢ üîë Chaves: ${stats.chats.keys.toLocaleString()}
‚Ä¢ ‚úÖ Hits: ${stats.chats.hits.toLocaleString()}
‚Ä¢ ‚ùå Misses: ${stats.chats.misses.toLocaleString()}
‚Ä¢ üìà Taxa: ${formatHitRate(stats.chats.hitRate)}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üìã *Legenda:*
‚Ä¢ TTL = Time To Live (tempo de vida)
‚Ä¢ Hits = Acessos com sucesso
‚Ä¢ Misses = Acessos sem sucesso
‚Ä¢ Taxa = Efici√™ncia do cache

üîÑ *Cache Manager Ativo*${contextInfo}`;

    await omniZapClient.sendMessage(targetJid, { text: cacheDetailsText });

    if (isGroupMessage) {
      console.log(
        `OmniZap: Detalhes do cache enviados para grupo ${targetJid} (solicitado por ${senderJid})`,
      );
    } else {
      console.log(`OmniZap: Detalhes do cache enviados para ${targetJid}`);
    }
  } catch (error) {
    console.error('OmniZap: Erro ao enviar detalhes do cache:', error);
    await omniZapClient.sendMessage(targetJid, {
      text: '‚ùå *Erro interno*\n\nOcorreu um erro ao obter os detalhes do cache.',
    });
  }
};

const sendUnknownCommandMessage = async (
  omniZapClient,
  targetJid,
  command,
  isGroupMessage = false,
  senderJid = null,
) => {
  const contextInfo = isGroupMessage
    ? `\n\nüë• *Contexto:* Grupo\nüë§ *Solicitante:* ${senderJid}`
    : `\n\nüë§ *Contexto:* Mensagem direta`;

  const unknownText = `‚ùì *Comando Desconhecido*

üö´ **Comando:** ${COMMAND_PREFIX}${command}

üí° **Dica:** Use ${COMMAND_PREFIX}help para ver todos os comandos dispon√≠veis${contextInfo}`;

  await omniZapClient.sendMessage(targetJid, { text: unknownText });
};

/**
 * Envia mensagem de erro
 */
const sendErrorMessage = async (
  omniZapClient,
  targetJid,
  isGroupMessage = false,
  senderJid = null,
) => {
  const contextInfo = isGroupMessage
    ? `\n\nüë• *Contexto:* Grupo\nüë§ *Solicitante:* ${senderJid}`
    : `\n\nüë§ *Contexto:* Mensagem direta`;

  await omniZapClient.sendMessage(targetJid, {
    text: `‚ùå *Erro interno*\n\nOcorreu um erro ao processar seu comando. Tente novamente.${contextInfo}`,
  });
};

/**
 * Manipulador de erros do OmniZap
 *
 * @param {Error} error - Objeto de erro
 */
const handleOmniZapError = (error) => {
  if (error.message && error.message.includes('network')) {
    console.error('OmniZap: Erro de rede detectado:', error.message);
  } else if (error.message && error.message.includes('timeout')) {
    console.error('OmniZap: Timeout detectado:', error.message);
  } else {
    console.error('OmniZap: Erro geral no processamento:', error);
  }
};

module.exports = OmniZapMessageProcessor;
